{"version":3,"names":[],"mappings":"","sources":["cache.js"],"sourcesContent":["const cacheSize = 1024;\nconst resetInterval = 1000; // reset requested bit\nconst blockedInterval = 10;\n\nclass Cache {\n  constructor(memory) {\n    this.memory = memory;\n    this.info = {\n      hit: 0,\n      miss: 0,\n      blocked: 0,\n    };\n    this.isBlocked = false;\n    this.cache = [];\n    for (let i = 0; i < cacheSize; i++) {\n      this.cache[i] = {\n        address: i,\n        value: this.memory.get(i),\n        requested: 0,\n      };\n    } // first init\n  }\n\n  isExist(pos) {\n    let i;\n    for (i = 0; i < this.cache.length; i++) {\n      if (this.cache[i].address === pos) {\n        this.cache[i].requested = 1;\n        setTimeout(() => { this.cache[i].requested = 0; }, resetInterval);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  findOldIndex() {\n    for (let i = 0; i < cacheSize + 1; i++) {\n      if (!this.cache[i].requested) return i;\n      this.cache[i].requested = 0;\n    }\n    return 0;\n  }\n\n  read(pos) {\n    if (this.isExist(pos)) {\n      this.info.hit += 1;\n    } else {\n      this.info.miss += 1;\n      const replaced = this.findOldIndex();\n      this.cache[replaced] = {\n        address: pos,\n        value: this.memory.get(pos),\n        requested: 1,\n      };\n      setTimeout(() => { this.cache[replaced].requested = 0; }, resetInterval);\n    }\n  }\n\n  write(pos) {\n    if (this.isBlocked) {\n      this.info.blocked += 1;\n      setTimeout(() => {\n        this.write(pos);\n      }, blockedInterval / 2); // ждем когда можно записать\n    } else {\n      this.isBlocked = true;\n      this.memory.set(pos, 1);\n      this.read(pos); // считаем, что тут перезаписывается значение в кэше, даже если оно уже там есть\n      setTimeout(() => { this.isBlocked = false; }, blockedInterval);\n    }\n  }\n\n\n}\n\nexport default Cache;\n"],"file":"cache.js"}