{"version":3,"names":[],"mappings":"","sources":["program.js"],"sourcesContent":["import Memory from './memory';\nimport Cache from './cache';\n\nconst varsCount = 100;\nconst arraysCount = 10;\nconst arraysLength = 50; // для рандома от x до 2x\nconst functionSizeL = 20;\nconst functionSizeC = 10;\n\nconst p_var = 30; // %\nconst p_arr = 20;\nconst p_func = 50;\n\nconst p_funcL = 65;\nconst p_funcC = 35;\n\nlet memory = new Memory();\n\nclass Program {\n\n  constructor() {\n    this.vars = [];\n    this.arrays = [];\n    this.functionsL = [];\n    this.functionsC = [];\n    this.memory = memory;\n    this.codeString = 0;\n    this.cache = null;\n  }\n\n  init() {\n    this.codeString = Math.floor(Math.random() * (10000 - 1000 + 1)) + 1000;\n    this.placeVars(); // compiles\n    this.placeArrays();\n    this.placeFunction();\n    this.workTime = 0;\n    this.cache = new Cache(this.memory); // init fill cache\n  }\n\n  run() {\n    const start = new Date();\n    for (let i = this.codeString; i > 0; i--) {\n      const code = Math.floor(Math.random() * 100);\n      if (code < p_var) {\n        this.handleVar();\n      } else {\n        if (code < p_var + p_arr) {\n          this.handleArray();\n        } else {\n          if (code < p_var + p_arr + p_func) {\n            this.executeFunction();\n          }\n        }\n      }\n    }\n    /**  result info **/\n    const allOperation = this.cache.info.hit + this.cache.info.miss;\n    const hitted = this.cache.info.hit / allOperation;\n    const missed = this.cache.info.miss / allOperation;\n    console.log(`hit: ${hitted.toFixed(7)}%`, `miss: ${missed.toFixed(7)}%`);\n    const now = new Date();\n    console.log(`blocked: ${this.cache.info.blocked}`, ' WorkTime: ms', (now.getTime() - start.getTime()), '\\n');\n    /*  result info */\n  }\n\n  executeFunction() {\n    if (Math.random() < (p_funcL / 100)) {\n      const index = Math.floor(Math.random() * this.functionsL.length);\n      for (let i = 0; i < this.functionsL[index].size; i++) {\n        this.cache.read(this.functionsL[index].start + i);\n      }\n    } else {\n      const index = Math.floor(Math.random() * this.functionsC.length);\n      const cicles = Math.floor(Math.random() * (11)) + 5;\n      for (let j = 0; j < cicles; j++) {\n        for (let i = 0; i < this.functionsL[index].size; i++) {\n          this.cache.read(this.functionsL[index].start + i);\n        }\n      }\n    }\n  }\n\n  handleArray() {\n    const index = Math.floor(Math.random() * this.arrays.length);\n    for (let i = 0; i < this.arrays[index].size; i++) {\n      this.cache.read(this.arrays[index].start + i);\n    }\n  }\n  handleVar() {\n    const index = Math.floor(Math.random() * this.vars.length);\n    if (Math.random() < 0.5) {\n      this.cache.read(this.vars[index].start);\n    } else {\n      this.cache.write(this.vars[index].start);\n    }\n  }\n\n  placeVars() {\n    for (let i = 0; i < varsCount; i++) {\n      this.vars.push({\n        start: this.memory.reserve(1),\n        size: 1,\n      });\n    }\n  }\n\n  placeArrays() {\n    let arraySize = 0;\n    for (let i = 0; i < arraysCount; i++) {\n      arraySize = Math.floor(Math.random() * (arraysLength + 1)) + arraysLength;\n      this.arrays.push({\n        start: this.memory.reserve(arraySize),\n        size: arraySize,\n      });\n    }\n  }\n\n  placeFunction() {\n    let funcSize;\n    for (let i = 0; i < Math.floor(this.codeString * (p_funcL / 100)); i++) {\n      funcSize = Math.floor(Math.random() * (functionSizeL + 1)) + functionSizeL;\n      this.functionsL.push({\n        start: this.memory.reserve(funcSize),\n        size: funcSize,\n      });\n    }\n    for (let i = 0; i < Math.floor(this.codeString * (p_funcC / 100)); i++) {\n      funcSize = Math.floor(Math.random() * (functionSizeC + 1)) + functionSizeC;\n      this.functionsC.push({\n        start: this.memory.reserve(funcSize),\n        size: funcSize,\n      });\n    }\n  }\n\n}\n\nexport default Program;\n"],"file":"program.js"}